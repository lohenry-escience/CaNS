"""
Defines the functions to process the relevant information written down by CaNS
"""
import os, sys, re
import f90nml #to read the nml files

def getDivergences(log_file_path):
    """
    Reads a log file generated by CaNS to get the divergence and divergence max
    Note: this assumes a certain format for div/divmax. In case of an incompatible format,
    or an absent file, will return an error

    Args:
        log_file_path: address of the log_file, returns empty vectors and prints out an error in case of absent log file.

    Returns: 
        dict: dictionnary of extracted values. values[Div,DivMax] = [list of values for steps]
    """
    values = {"DivTot":[],"DivMax":[]}
    if not os.path.isfile(log_file_path):
        raise FileNotFoundError(f"ERROR: In getAllTimings: could not open {log_file_path}.")
        return timings
    with open(log_file_path,'r') as log_file:
        for line_number, line in enumerate(log_file, start=1):
            line = line.strip()
            if "Total divergence" in line:
                values["DivTot"].append(float(line.split()[4])) # The divergence is given by the 4th value
                values["DivMax"].append(float(line.split()[-1])) # The divergence is given by the last value    
    return values

def getDts(log_file_path):
    """
    Reads a log file generated by CaNS to get the dt and dtmax
    Note: this assumes a certain format for dt/dtmax. In case of an incompatible format,
    or an absent file, will return an error

    Args:
        log_file_path: address of the log_file, returns empty vectors and prints out an error in case of absent log file.

    Returns: 
        dict: dictionnary of extracted values. values[dt,dtmax] = [list of values for steps]
    """
    values = {"dt":[],"dtMax":[]}
    if not os.path.isfile(log_file_path):
        raise FileNotFoundError(f"ERROR: In getAllTimings: could not open {log_file_path}.")
        return timings
    with open(log_file_path,'r') as log_file:
        for line_number, line in enumerate(log_file, start=1):
            line = line.strip()
            if "dtmax =" in line:
                values["dtMax"].append(float(line.split()[2 ])) # The dtMax is given by the 4th value
                values["dt"   ].append(float(line.split()[-1])) # The dt is given by the last value
    return values

def getAllTimings(log_file_path):
    """
    Reads a log file generated by CaNS to get the timings of all the steps
    Note: this assumes a certain format for timings. In case of an incompatible format,
    or an absent file, will return an error

    Args:
        log_file_path: address of the log_file, returns empty vectors and prints out an error in case of absent log file.

    Returns: 
        dict: dictionnary of extracted values. timings[Time,Average,Min,Max] = [list of values for steps]
    """
    timings = {"Total":[],"Average":[],"Min":[],"Max":[]}
    if not os.path.isfile(log_file_path):
        raise FileNotFoundError(f"ERROR: In getAllTimings: could not open {log_file_path}.")
        return timings
    with open(log_file_path,'r') as log_file:
        previous_line = None
        for line_number, line in enumerate(log_file, start=1):
            line = line.strip()
            
            if "Time step" in line:
                timings["Total"].append(float(line.split()[-1])) # The timing is given by the last value
            elif "Avrg, min & max elapsed time" in line:
                previous_line = line_number  # Mark this line for follow-up
            elif previous_line is not None:
                # Extract numerical values (or any other patterns) from this line
                match = line.split()
                if match and len(match)==3:                    
                    timings["Average"].append(float(match[0]))
                    timings["Min"    ].append(float(match[1]))
                    timings["Max"    ].append(float(match[2]))
                else:
                    raise ValueError(f"Expected 3 numerical values after 'Avrg, min & max elapsed time' at line {previous_line}, but found: '{line}'")
                previous_line = None  # Reset after handling the relevant line
    return timings

def readInputFile(input_file_path):
    """
    Reads the input file in order to find the indices at which divergence checks and writings occur

    Args:
        input_file_path: path of the .nml input file

    Returns:
        dict: dictionary with all values of the input file
    """

    if not os.path.isfile(input_file_path):
        raise FileNotFoundError(f"ERROR: In readInputFile: could not open {input_file_path}.")
        return timings
    
    nml = f90nml.read('input.nml')
    return nml["dns"]
    
def classifyTimings(timings, nml_info, start_end_veto=1):
    """
    Returns 3 vectors of timing, one for non-divergence, non-writing steps,
    one for divergence checks, and one for writing steps.    
    
    Args:
        timings: dictionnary of timings (keys: Total, Average, Min, Max) where each item is a list of step timings. Typically the ouput of getAllTimings
        nml_info: dictionnary of input parameters, typically the output of readInputFile. Must have the following keys:
        - icheck, iout0d, iout1d, iout2d, iout3d, isave
        start_end_veto: optional parameter to make sure we do not take into account start/end steps that may skew the reading
    
    Returns:
        dict: dictionnary of the timings entries that correspond to normal steps, check steps, writing steps, and the start/end steps
    """
    classified_timings = {"NormalStep":{},"CheckStep":{}, "OutStep": {}, "WritingStep":{}, "StartStep":{}, "EndStep":{}}
    for timing_type in timings.keys():
        n_timings = len(timings[timing_type])
        for class_timing in classified_timings.keys():
            classified_timings[class_timing][timing_type] = []
            classified_timings[class_timing]["iStep"    ] = []
        for i, time in enumerate(timings[timing_type]):
            # Modulo checks need i+1 as steps start at 1
            step_type = "NormalStep"
            if i < start_end_veto:
                step_type = "StartStep"
            elif i > n_timings - start_end_veto - 1:
                step_type = "EndStep"
            elif (i + 1) % nml["isave"] == 0:
                step_type = "WritingStep"                
            elif ((i + 1) % nml["iout0d"] == 0 or
                  (i + 1) % nml["iout1d"] == 0 or
                  (i + 1) % nml["iout2d"] == 0 or
                  (i + 1) % nml["iout3d"] == 0):
                step_type = "OutStep"
            elif (i + 1) % nml["icheck"] == 1:
                step_type = "CheckStep"
            classified_timings[step_type][timing_type].append(time)
            classified_timings[step_type]["iStep"].append(i)
    return classified_timings

if __name__ == "__main__":
    print("INFO: Print average info for testing purposes")
    timings = getAllTimings("log_file.log")
    divs    = getDivergences("log_file.log")
    dts     = getDts        ("log_file.log")
    nml     = readInputFile("input.nml")
    class_timings = classifyTimings(timings,nml)
    # Print the timings
    print("======================")
    print("Timing information")
    for timeType, timings in class_timings.items():
        print("Time type:",timeType)
        for timing, val in timings.items():
            if timing == "iStep":
                continue
            if len(val) == 0:
                print("\t No values for",timing)
            else:
                av = sum(val)/len(val)
                print("\t",timing,":",av)
    
    # Print the divergences
    print("======================")
    print("Divergence information")
    if len(divs["DivTot"]) == 0:
        print("No information found in the log file!")
    else:
        print("Total divergence min/max/av:",min(divs["DivTot"]),max(divs["DivTot"]),sum(divs["DivTot"])/len(divs["DivTot"]))
        print("Max divergence min/max/av  :",min(divs["DivMax"]),max(divs["DivMax"]),sum(divs["DivMax"])/len(divs["DivMax"]))

    # Print the dt
    print("======================")
    print("DT information")
    if len(dts["dt"]) == 0:
        print("No information found in the log file!")
    else:
        print("dt min/max/av       :",min(dts["dt"   ]),max(dts["dt"   ]),sum(dts["dt"   ])/len(dts["dt"   ]))
        print("max(dt) min/max/av  :",min(dts["dtMax"]),max(dts["dtMax"]),sum(dts["dtMax"])/len(dts["dtMax"]))
        
